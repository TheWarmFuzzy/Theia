<!DOCTYPE html>
<html>
<head>
	<style>
		body{
			margin:0px;
			overflow:hidden;
			background-color: #fff;
		}
		video, canvas{
			position:absolute;
			top:50%;
			margin-top:-225px;
			left:50%;
			margin-left:-300px;
		}
		canvas{
			z-index:100;
		}
	
	</style>
	<meta http-equiv="Cache-Control" content="no-store" />
	<meta name="mobile-web-app-capable" content="yes">
</head>
<body>
	<!--<script type="text/javascript" src="lib/grid.js"></script>
	<script type="text/javascript" src="lib/version.js"></script>
	<script type="text/javascript" src="lib/detector.js"></script>
	<script type="text/javascript" src="lib/formatinf.js"></script>
	<script type="text/javascript" src="lib/errorlevel.js"></script>
	<script type="text/javascript" src="lib/bitmat.js"></script>
	<script type="text/javascript" src="lib/datablock.js"></script>
	<script type="text/javascript" src="lib/bmparser.js"></script>
	<script type="text/javascript" src="lib/datamask.js"></script>
	<script type="text/javascript" src="lib/rsdecoder.js"></script>
	<script type="text/javascript" src="lib/gf256poly.js"></script>
	<script type="text/javascript" src="lib/gf256.js"></script>
	<script type="text/javascript" src="lib/decoder.js"></script>
	<script type="text/javascript" src="lib/qrcode.js"></script>
	<script type="text/javascript" src="lib/findpat.js"></script>
	<script type="text/javascript" src="lib/alignpat.js"></script>
	<script type="text/javascript" src="lib/databr.js"></script>-->

	<script type="text/javascript" src="lib/llqrcode.js"></script>    
    <script type="text/javascript" src="lib/qrcode.js"></script>
	
	<script type="text/javascript" src="lib/theia_lib.js"></script>
	<script type="text/javascript" src="lib/camera.js"></script>
	<script type="text/javascript" src="lib/three.min.js"></script>
	<script type="text/javascript" src="lib/OBJLoader.js"></script>
	<script type="text/javascript" src="lib/3DOverlay.js"></script>
	<script type="text/javascript" src="lib/tracking_mk_theia.js"></script>
	<script type="text/javascript" src="lib/debug.js"></script>
	<script type="text/javascript" src="lib/jquery-1.11.3.js"></script>
	<script type="text/javascript" src="lib/QR_Code.js"></script>
	<script type="text/javascript">
		var debug = new Debug();
		debug.toggle_enabled();
		
		var camera = new Camera(600, 450);
		camera.start();
		
		var tracker = new tracking.ColorTracker();
		var test = tracking.track(camera,tracker);
		
		var overlay = new Overlay(600, 450);		
		
		var qr_handler = new QR_Code(camera, overlay);
		
		tracker.on('track', function(event) {
			//camera.ctx.clearRect(0, 0, camera.width, camera.height);
			//var orientation = "";
			/*if(typeof event.data[0] == "string"){
				console.log("fuck");
				window.cancelAnimationFrame(test);
				tracker = new tracking.ColorTracker();
				tracking.track(camera,tracker);
			}else{
				
			}*/
			
			draw_boxes(camera, event.data);
			/*var qr_code = qr_code_validation(event.data);
			if(qr_code["validated"]){
				orientation = qr_code["orientation"];
				var points = get_points(event.data);
				var canvas = camera.getFrame();
				draw_overlay(camera,points);
				var qr = remap(canvas, points, 100, 100);
				document.body.appendChild(qr);
				try{
					console.log();
				}catch(e){
					
				}
				position_cat(event.data);
			}
			update_position();*/
			qr_handler.update(event.data);
			camera.update();
		});
		
		function update_position(){
			var object = overlay.get_object("Test Object");
			overlay.update(object);
		}
		
		function qr_code_validation(rectangles){
			var validated = false;
			rects = new Array();
			rects["red"] = new Array();
			rects["green"] = new Array();
			var red = 0, green = 0;
			rectangles.forEach(function(rect) {
				if (rect.color == 'theia_red'){
					red++;
					rects["red"].push(rect);
				}
				
				if (rect.color == 'theia_green'){
					green++;
					rects["green"].push(rect);
				}
					
				if(red == 3 && green == 1)
					validated = true;
			});
			var orientation = "";
			if(validated){
				var below = 0, right = 0;
				for(i = 0; i < 3; i++){
					
					if(rects["green"][0].x >= rects["red"][i].x)
						right += 1;
						
					if(rects["green"][0].y >= rects["red"][i].y)
						below += 1;
				}
			}
			return {"orientation":orientation,"validated":validated};
		}
		
		function draw_boxes(cam, rectangles){
		
			var i = 0;
			var c_ctx = cam.get_canvas_context();
			
			rectangles.forEach(function(rect) {
				i++;
				if (rect.color == 'theia_red') {
					rect.colour = "#aa0000";
				}
				
				if (rect.color == 'theia_green') {
					rect.colour = "#00aa00";
				}
								
				c_ctx.strokeStyle = rect.colour;
				c_ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
				c_ctx.font = '11px Helvetica';
				c_ctx.fillStyle = "#fff";
				c_ctx.fillText('x: ' + rect.x + 'px', rect.x + rect.width + 5, rect.y + 11);
				c_ctx.fillText('y: ' + rect.y + 'px', rect.x + rect.width + 5, rect.y + 22);
				c_ctx.fillText('#: ' + i, rect.x + rect.width + 5, rect.y + 33);
			});
		}
		
		function position_cat(rectangles){
			
			var x1 = 0, y1 = 0;
			var scale = 0;
			rectangles.forEach(function(rect) {
				
				if(rectangles.length == 4){
					x1 += rect.x + rect.width  * 0.5;
					y1 += rect.y + rect.height  * 0.5;
					scale += rect.width + rect.height;
				}
				
			});
			
			if(rectangles.length == 4){
				var object = overlay.get_object("Test Object");
				x1 *= 0.25;
				y1 *= 0.25;
				scale *= 0.0075;
				overlay.set_object_position(object,x1,y1);
				overlay.set_object_scale(object,scale);
			}
		}
		
		function get_points(data){
			/*var points = new Array();
			
			points.push({"x":data[0].x,"y":data[0].y});
			points.push({"x":data[1].x + data[1].width,"y":data[1].y});
			points.push({"x":data[3].x + data[3].width,"y":data[3].y + data[3].height});
			points.push({"x":data[2].x,"y":data[2].y + data[2].height});
			return points;
			
			var s1, s2, s3;
			var minS, maxS;
			var dId, dS;
			
			s1 = data[0].x == data[3].x ? Infinity : (data[0].y - data[3].y) / (data[0].x - data[3].x);
			s2 = data[1].x == data[3].x ? Infinity : (data[1].y - data[3].y) / (data[1].x - data[3].x);
			s3 = data[2].x == data[3].x ? Infinity : (data[2].y - data[3].y) / (data[2].x - data[3].x);
			
			minS = Math.min(s1, s2, s3);
			maxS = Math.max(s1, s2, s3);
			
			if(minS != s1 && maxS != s1){
				dId = 0;
				dS = s1;
			}
			
			if(minS != s2 && maxS != s2){
				dId = 1;
				dS = s2;
			}
			
			if(minS != s3 && maxS != s3){
				dId = 3;
				dS = s3;
			}
			
			//First Point
			points.push({"x":data[dId].x,"y":data[dId].y});
			
			if(dS > 0){
				if(data[dId].x > data[3].x){
					for(i = 0; i < 3; i++){
						if(dId == i)
							continue;
						if(data[i].x > data[3].x){
							points.push({"x":data[dId].x,"y":data[dId].y});
						}else{
						
						}
						break;
					}
				}else{
				
				}
			}else{
				if(data[dId].x > data[3].x){
				
				}else{
				
				}
			}*/
			var xAvg, yAvg;
			xAvg = (data[0].x + data[1].x + data[2].x + data[3].x) * 0.25;
			yAvg = (data[0].y + data[1].y + data[2].y + data[3].y) * 0.25;
			for(var i = 0; i < 4; i++){
				if(data[i].x > xAvg)
					data[i].x += data[i].width;
					
				if(data[i].y > yAvg)
					data[i].y += data[i].height;
			}
			
			var points = new Array();
			
			//Finds largest distance (won't work properly if skewed)
			var l1, l2, l3;
			
			//Get distances
			l1 = Math.pow(data[0].x - data[3].x,2) + Math.pow(data[0].y - data[3].y,2);
			l2 = Math.pow(data[1].x - data[3].x,2) + Math.pow(data[1].y - data[3].y,2);
			l3 = Math.pow(data[2].x - data[3].x,2) + Math.pow(data[2].y - data[3].y,2);
			
			//Find largest distance and corresponding id
			var p1, p2, p3;
			p1 = 0;
			p2 = 1;
			p3 = 2;
			var lMax = l1;
			if(lMax < l2){
				p1 = 1;
				p2 = 0;
				p3 = 2;
				lMax = l2;
			}
			
			if(lMax < l3){
				p1 = 2;
				p2 = 0;
				p3 = 1;
				lMax = l3;
			}
			
			//First Point
			points.push({"x":data[p1].x,"y":data[p1].y});
			
			var p1Dx, p2Dx, p3Dx, p1Dy, p2Dy, p3Dy;
			p1Dx = data[p1].x - data[3].x;
			p1Dx = p1Dx == 0 ? 0.000000000000000000000001 : p1Dx; 
			p1Dy = data[p1].y - data[3].y;
			
			p2Dx = data[p2].x - data[3].x;
			p2Dx = p2Dx == 0 ? 0.000000000000000000000001 : p2Dx; 
			p2Dy = data[p2].y - data[3].y;
			
			/*p3Dx = data[2].x - data[3].x;
			p3Dx = p3Dx == 0 ? 0.000000000000000000000001 : p3Dx; 
			p3Dy = data[2].y - data[3].y;*/
			
			var p1A, p2A, p3A;
			p1A = Math.atan2(p1Dy,p1Dx);
			p2A = Math.atan2(p1Dy,p1Dx);
			//p3A = Math.atan2(p1Dy,p1Dx);
			
			//Adds last 3 points
			if(p2A - p1A < 0){
				//Second Point
				points.push({"x":data[p2].x,"y":data[p2].y});
				//Third Point
				points.push({"x":data[3].x,"y":data[3].y});
				//Fourth Point
				points.push({"x":data[p3].x,"y":data[p3].y});
			}else{
				//Second Point
				points.push({"x":data[p3].x,"y":data[p3].y});
				//Third Point
				points.push({"x":data[3].x,"y":data[3].y});
				//Fourth Point
				points.push({"x":data[p2].x,"y":data[p2].y});
			}
				
			return points;
		}
		
	</script>
	
</body>
</html>